// Generated by CoffeeScript 1.8.0
(function() {
  var authLastRequestChallenger, authProfile, authRequestCount, blockAuthRequest, checkStatus, getAuthProfile, setAuthProfile, setConnStat, setIcon, updateStatus;

  authProfile = null;

  authLastRequestChallenger = null;

  authRequestCount = 0;

  blockAuthRequest = false;

  setIcon = function(st) {
    switch (st) {
      case "on":
        return chrome.browserAction.setIcon({
          'path': {
            '19': 'image/icon_19.png',
            '38': 'image/icon_38.png'
          }
        });
      case "on_sec":
        return chrome.browserAction.setIcon({
          'path': {
            '19': 'image/icon_19.png',
            '38': 'image/icon_38.png'
          }
        });
      case "off_alt":
        chrome.browserAction.setIcon({
          'path': {
            '19': 'image/off_icon_19.png',
            '38': 'image/off_icon_38.png'
          }
        });
        return chrome.browserAction.setTitle({
          title: "Proxy disabled, use system settings"
        });
      default:
        chrome.browserAction.setIcon({
          'path': {
            '19': 'image/off_icon_19.png',
            '38': 'image/off_icon_38.png'
          }
        });
        return chrome.browserAction.setTitle({
          title: "Proxy disabled."
        });
    }
  };

  setConnStat = function(text) {
    return chrome.browserAction.setTitle({
      title: "Connect to " + text
    });
  };

  checkStatus = function(isLoop, callback) {
    return chrome.proxy.settings.get({
      'incognito': false
    }, function(config) {
      updateStatus(config);
      if (isLoop === false) {
        setTimeout(checkStatus, 1000 * 30);
      }
      if (callback) {
        return callback(config);
      }
    });
  };

  updateStatus = function(config) {
    var controlable;
    controlable = false;
    if (config.levelOfControl === 'controlled_by_this_extension') {
      if (config.value.mode === 'fixed_servers' && config.value.rules.singleProxy.scheme === 'https') {
        setIcon('on_sec');
      } else if (config.value.mode === 'system') {
        setIcon('off_alt');
      } else {
        setIcon('on');
      }
      controlable = true;
    }
    if (config.levelOfControl === 'controllable_by_this_extension') {
      setIcon('off');
      controlable = true;
    }
    if (controlable) {
      if (config.value.mode === 'direct') {
        return setIcon('off');
      }
    } else {
      return setIcon('off');
    }
  };

  setAuthProfile = function(profile) {
    if (profile.use_auth) {
      authProfile = profile;
    }
    blockAuthRequest = false;
  };

  getAuthProfile = function() {
    var profiles, selected;
    if (authProfile) {
      return authProfile;
    }
    profiles = localStorage.getItem("Profile");
    selected = localStorage.getItem("selected");
    if (!profiles) {
      return;
    }
    if (!selected) {
      return;
    }
    profiles = JSON.parse(profiles);
    if (!profiles) {
      console.log("Unable to parse profile from localStorage.");
      return null;
    }
    profiles = profiles.filter(function(profile) {
      if (profile.name === selected) {
        return true;
      }
    });
    if (profiles.length > 0) {
      setAuthProfile(profiles[0]);
      return authProfile;
    }
    console.log("No profile found.");
    return null;
  };

  chrome.webRequest.onAuthRequired.addListener(function(details, callback) {
    var profile;
    if (!details.isProxy) {
      return callback();
    }
    if (!details.challenger) {
      return callback();
    }
    console.log('Proxy authorization request: ' + JSON.stringify(details));
    if (blockAuthRequest) {
      console.log("Blocking proxy authorization request due to too many failure.");
      return callback();
    }
    if (!authLastRequestChallenger) {
      authLastRequestChallenger = details.challenger;
    }
    if (JSON.stringify(authLastRequestChallenger) !== JSON.stringify(details.challenger)) {
      console.log('Proxy authorization challenger changed from ' + JSON.stringify(authLastRequestChallenger) + ' to ' + JSON.stringify(details.challenger));
      authLastRequestChallenger = details.challenger;
      authRequestCount = 0;
    }
    authRequestCount++;
    profile = getAuthProfile();
    if (!profile || !profile.use_auth) {
      console.log('Authorization profile not set, skip this request.');
      return callback();
    }
    if (profile.host.indexOf(details.challenger.host) === -1) {
      console.log('Challenger dismatch, should be "' + profile.host + '", got "' + details.challenger.host('", skip this request.'));
      return callback();
    }
    if (authRequestCount > 3) {
      alert("Incorrect username or password, please change your proxy settings or contact with administrator.");
      authRequestCount = 0;
      blockAuthRequest = true;
      return callback();
    }
    return callback({
      authCredentials: {
        username: profile.username,
        password: profile.password
      }
    });
  }, {
    urls: ["<all_urls>"]
  }, ["asyncBlocking"]);

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    switch (request.msg) {
      case 'update_status':
        checkStatus(false, function(config) {
          return sendResponse({
            status: 'ok',
            config: JSON.stringify(config)
          });
        });
        break;
      case 'set_icon':
        setIcon(request.name);
        sendResponse({
          status: 'ok'
        });
        break;
      case 'set_conn_stat':
        setConnStat(request.name);
        sendResponse({
          status: 'ok'
        });
        break;
      case 'set_auth':
        setAuthProfile(request.profile);
        sendResponse({
          status: 'ok'
        });
    }
    return true;
  });

}).call(this);
